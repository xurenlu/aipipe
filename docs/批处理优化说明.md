# 批处理优化说明

## 🎯 优化目标

**将多行日志批量发送给 AI 分析，而不是逐行发送**

### 核心优势

1. **大幅节省 Token**：不重复发送 system prompt
2. **减少 API 调用**：10 行日志只调用 1 次 API
3. **减少通知次数**：多条重要日志只发 1 次通知
4. **提高处理效率**：批量处理比逐行更快
5. **降低运营成本**：节省 80-90% 的 API 费用

## 📋 用户反馈的问题

> "现在一行一发，有点受不了"

**原因分析：**
1. 每行日志都调用一次 API（1-3秒延迟）
2. 每次调用都发送完整的 system prompt（浪费 token）
3. 每条重要日志都发送通知（频繁打扰）

**解决方案：**批处理模式

## 🔧 批处理机制

### 工作原理

```
日志输入流
    ↓
累积日志（抖动处理）
    ├─ 达到 10 行 → 立即处理
    └─ 等待 3 秒 → 自动处理
    ↓
本地预过滤（DEBUG/INFO）
    ↓
批量调用 AI（剩余日志）
    ↓
显示批次摘要 + 逐行结果
    ↓
只发送一次通知
```

### 抖动（Debounce）策略

**触发条件（满足任一即触发）：**
1. **数量触发**：累积达到 N 行（默认 10 行）
2. **时间触发**：等待 T 秒后自动处理（默认 3 秒）

**示例：**
```
0s: 收到第 1 行 → 启动 3 秒定时器
1s: 收到第 2 行 → 重置定时器
2s: 收到第 3 行 → 重置定时器
...
2.5s: 收到第 10 行 → 立即处理（达到批处理大小）

或者：
0s: 收到第 1 行 → 启动 3 秒定时器
1s: 收到第 2 行 → 重置定时器
4s: 无新日志 → 定时器到期，处理 2 行
```

## 💻 使用方法

### 基本使用（批处理模式，默认）

```bash
# 标准输入
cat app.log | ./aipipe --format java

# 文件监控
./aipipe -f app.log --format java
```

**特点：**
- ✅ 自动批处理（10 行或 3 秒）
- ✅ 本地过滤 DEBUG/INFO
- ✅ 批量调用 AI
- ✅ 只发一次通知

### 自定义批处理参数

```bash
# 每批最多 5 行
./aipipe -f app.log --format java --batch-size 5

# 等待 1 秒后处理
./aipipe -f app.log --format java --batch-wait 1s

# 组合使用
./aipipe -f app.log --format java --batch-size 20 --batch-wait 5s
```

### 禁用批处理（逐行模式）

```bash
./aipipe -f app.log --format java --no-batch
```

**特点：**
- ❌ 每行单独调用 API
- ❌ 更多通知
- ❌ 更多费用
- ✅ 实时性更好（无延迟）

## 📊 性能对比

### 示例场景：100 条日志

假设：
- DEBUG/INFO: 70 条（本地过滤）
- ERROR/WARN: 30 条（需要 AI）

| 指标 | 逐行模式 | 批处理模式 | 改进 |
|------|---------|-----------|------|
| **API 调用次数** | 30 次 | 3 次 | ↓ 90% |
| **System Prompt 发送** | 30 次 | 3 次 | ↓ 90% |
| **Token 消耗** | ~90,000 | ~15,000 | ↓ 83% |
| **总耗时** | 60-90秒 | 6-9秒 | ↑ 10倍 |
| **通知次数** | 10-15 次 | 1-3 次 | ↓ 80% |
| **API 费用** | 100% | 17% | ↓ 83% |

### Token 消耗详细计算

**System Prompt 大小：** ~2000 tokens（包含 60+ 示例）

**逐行模式：**
```
30 次 API 调用 × (2000 system + 100 user + 50 response) = 64,500 tokens
```

**批处理模式（每批 10 行）：**
```
3 次 API 调用 × (2000 system + 1000 user + 500 response) = 10,500 tokens
```

**节省：** 54,000 tokens (83%)

## 📤 输出示例

### 批处理模式输出

```bash
$ cat test-batch.log | ./aipipe --format java

🚀 AIPipe 启动 - 监控 java 格式日志
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📥 从标准输入读取日志...
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📋 批次摘要: 发现数据库和认证错误 (重要日志: 3 条)

🔇 [过滤] 2025-10-13 10:00:00 INFO Application started successfully
🔇 [过滤] 2025-10-13 10:00:01 INFO User logged in: alice@example.com
🔇 [过滤] 2025-10-13 10:00:02 DEBUG Processing request parameters
🔇 [过滤] 2025-10-13 10:00:03 INFO Retrieved 20 records from database
⚠️  [重要] 2025-10-13 10:00:04 ERROR Database connection timeout
   📝 数据库连接超时
⚠️  [重要] 2025-10-13 10:00:05 ERROR NullPointerException at line 123
   📝 空指针异常
⚠️  [重要] 2025-10-13 10:00:06 WARN Memory usage high: 85%
   📝 内存使用率过高
🔇 [过滤] 2025-10-13 10:00:07 INFO Request completed in 50ms
⚠️  [重要] 2025-10-13 10:00:08 ERROR Authentication failed
   📝 认证失败
🔇 [过滤] 2025-10-13 10:00:09 INFO Health check OK
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 统计: 总计 10 行, 过滤 6 行, 告警 4 次, 批次 1 个

[通知] ⚠️ 重要日志告警
       发现数据库和认证错误
```

### 逐行模式输出（对比）

```bash
$ cat test-batch.log | ./aipipe --format java --no-batch

🔇 [过滤] ...
🔇 [过滤] ...
⚠️  [重要] 2025-10-13 10:00:04 ERROR Database connection timeout
   📝 摘要: 数据库连接超时
[通知 1] 数据库连接超时

⚠️  [重要] 2025-10-13 10:00:05 ERROR NullPointerException
   📝 摘要: 空指针异常
[通知 2] 空指针异常

⚠️  [重要] 2025-10-13 10:00:06 WARN Memory usage high
   📝 摘要: 内存使用率过高
[通知 3] 内存使用率过高

⚠️  [重要] 2025-10-13 10:00:08 ERROR Authentication failed
   📝 摘要: 认证失败
[通知 4] 认证失败

📊 统计: 总计 10 行, 过滤 6 行, 告警 4 次
```

**对比：**
- 批处理：1 个批次摘要，1 次通知
- 逐行：4 个单独摘要，4 次通知

## 🎯 批处理响应格式

### AI 返回格式

```json
{
  "results": [
    {"should_filter": true, "summary": "INFO级别", "reason": "..."},
    {"should_filter": true, "summary": "正常登录", "reason": "..."},
    {"should_filter": false, "summary": "数据库超时", "reason": "ERROR级别"},
    {"should_filter": false, "summary": "空指针异常", "reason": "异常需关注"}
  ],
  "overall_summary": "发现数据库和异常错误",
  "important_count": 2
}
```

**字段说明：**
- `results`：每行日志的分析结果（数组长度必须等于输入行数）
- `overall_summary`：整批日志的总体摘要（用于通知）
- `important_count`：重要日志数量

### 请求示例

```json
{
  "messages": [
    {
      "role": "system",
      "content": "你是专业的日志分析助手..."
    },
    {
      "role": "user",
      "content": "请批量分析以下日志，对每一行给出判断：\n\n[1] 2025-10-13 INFO ...\n[2] 2025-10-13 ERROR ..."
    }
  ]
}
```

## ⚙️ 配置参数

### --batch-size（批处理大小）

**默认值：** 10

**说明：** 累积多少行日志后立即处理

**建议值：**
- 低频日志（< 10行/分钟）：5-10
- 中频日志（10-100行/分钟）：10-20
- 高频日志（> 100行/分钟）：20-50

```bash
# 小批次（更实时，但调用更频繁）
./aipipe -f app.log --format java --batch-size 5

# 大批次（更节省，但延迟更高）
./aipipe -f app.log --format java --batch-size 20
```

### --batch-wait（批处理等待时间）

**默认值：** 3s

**说明：** 累积日志后等待多久自动处理

**建议值：**
- 实时监控：1-3s
- 后台分析：5-10s
- 历史日志：10-30s

```bash
# 更实时（延迟小，但可能批次多）
./aipipe -f app.log --format java --batch-wait 1s

# 更高效（延迟大，但批次更大）
./aipipe -f app.log --format java --batch-wait 10s
```

### --no-batch（禁用批处理）

**说明：** 回到逐行分析模式

**适用场景：**
- 需要最低延迟
- 日志量很小
- 调试和测试

```bash
./aipipe -f app.log --format java --no-batch
```

## 🧪 测试方法

### 快速测试

```bash
./test-batch-processing.sh
```

### 手动测试

```bash
# 创建测试日志
cat > test.log << 'EOF'
2025-10-13 INFO Line 1
2025-10-13 DEBUG Line 2
2025-10-13 ERROR Line 3
2025-10-13 INFO Line 4
2025-10-13 ERROR Line 5
EOF

# 批处理模式
cat test.log | ./aipipe --format java --verbose

# 逐行模式（对比）
cat test.log | ./aipipe --format java --no-batch --verbose
```

## 💡 实际应用

### 场景 1: 实时监控高频日志

```bash
# 每批 20 行，等待 2 秒
./aipipe -f /var/log/app.log --format java --batch-size 20 --batch-wait 2s
```

**适合：**
- 高流量应用
- 每分钟 100+ 条日志
- 需要快速发现问题但不要太多通知

### 场景 2: 后台监控低频日志

```bash
# 每批 5 行，等待 10 秒
./aipipe -f /var/log/app.log --format java --batch-size 5 --batch-wait 10s
```

**适合：**
- 低流量应用
- 每分钟 < 10 条日志
- 节省 API 费用

### 场景 3: 历史日志分析

```bash
# 大批次，快速处理
cat old.log | ./aipipe --format java --batch-size 50 --batch-wait 5s
```

**适合：**
- 分析历史日志
- 快速过滤大量数据
- 不需要实时性

### 场景 4: 调试和测试

```bash
# 禁用批处理，实时查看每行结果
tail -f dev.log | ./aipipe --format java --no-batch --verbose
```

**适合：**
- 开发环境调试
- 需要查看每行的详细分析
- 日志量小

## 🔍 批处理详情

### 批次摘要

批处理模式会显示一个整体摘要：

```
📋 批次摘要: 发现数据库和认证错误 (重要日志: 3 条)
```

**内容：**
- 整批日志的核心问题概述
- 重要日志的数量统计

### 通知策略

**批处理模式：**
- 一个批次只发送 1 次通知
- 通知内容包含：
  - 整体摘要
  - 重要日志数量
  - 如果 ≤ 3 条，显示具体日志内容

**逐行模式：**
- 每条重要日志发送 1 次通知
- 可能导致通知轰炸

### 统计信息

```
📊 统计: 总计 100 行, 过滤 80 行, 告警 20 次, 批次 3 个
```

**新增字段：**
- `批次 N 个`：处理了几个批次

## 🚀 性能提升

### Token 节省

**场景：** 100 条日志，30 条 ERROR/WARN

| 模式 | System Prompt | User Prompt | Response | 总计 |
|------|--------------|-------------|----------|------|
| 逐行 | 60,000 (30×2000) | 3,000 | 1,500 | 64,500 |
| 批处理 | 6,000 (3×2000) | 9,000 | 4,500 | 19,500 |
| **节省** | **54,000** | - | - | **45,000 (70%)** |

### 处理时间

**场景：** 实时监控，每分钟 60 条日志（20 条需要 AI）

| 模式 | 每分钟 API 调用 | 每分钟耗时 | 延迟 |
|------|---------------|-----------|------|
| 逐行 | 20 次 | 40-60秒 | 实时 |
| 批处理 | 2 次 | 4-6秒 | 1-3秒 |

### 通知次数

**场景：** 1 小时内 10 次错误告警

| 模式 | 通知次数 | 用户体验 |
|------|---------|---------|
| 逐行 | 10 次 | 频繁打扰 |
| 批处理 | 1-3 次 | 清爽简洁 |

## ⚠️ 注意事项

### 1. 延迟问题

批处理会引入延迟：
- 最小延迟：立即（达到批处理大小）
- 最大延迟：batch-wait 时间（默认 3秒）

**建议：**
- 实时监控：`--batch-wait 1s`
- 后台分析：`--batch-wait 10s`

### 2. 内存使用

批处理会在内存中累积日志：
- 默认 10 行：影响很小（< 1KB）
- 大批次 100 行：仍然很小（< 10KB）
- 不会有明显影响

### 3. 结果数量匹配

AI 必须返回与输入行数相同的结果数量。

**容错处理：**
- 如果 AI 返回少了，自动补充默认结果（过滤）
- 如果 AI 返回多了，只取前 N 个

## 📚 相关文档

- `README_aipipe.md` - 主要使用文档
- `test-batch-processing.sh` - 批处理测试脚本
- `AIPIPE_SUMMARY.md` - 项目总结

## 🎉 总结

批处理模式是一个重大优化：

**✅ 优势：**
- 节省 70-90% 的 Token
- 减少 80-90% 的 API 调用
- 减少 70-90% 的通知次数
- 提高 10 倍处理速度（批量场景）

**✅ 特性：**
- 智能抖动（数量 + 时间触发）
- 本地预过滤（DEBUG/INFO 不调用 AI）
- 批次摘要（整体概览）
- 单次通知（避免轰炸）

**✅ 灵活性：**
- 可配置批处理大小
- 可配置等待时间
- 可禁用批处理（逐行模式）

---

**更新日期**: 2025-10-13  
**版本**: 2.0.0  
**状态**: ✅ 已实现  
**推荐**: ⭐⭐⭐⭐⭐ 强烈推荐批处理模式

