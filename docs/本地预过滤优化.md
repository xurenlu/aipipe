# 本地预过滤优化

## 🎯 优化目标

**对于明确的低级别日志（DEBUG、INFO、TRACE），直接在本地过滤，不调用 AI API**

### 优势

1. **节省费用**：减少 60-80% 的 API 调用
2. **提高速度**：本地过滤 < 0.1秒，API 调用需要 1-3秒
3. **降低延迟**：不依赖网络，即时响应
4. **减少负载**：降低对 API 服务的压力

## 📋 实现原理

### 处理流程

```
日志输入
    ↓
本地预过滤检测
    ↓
    ├─→ 检测到 DEBUG/INFO/TRACE → 直接过滤（不调用 AI）✅
    ├─→ 检测到 ERROR/WARN/FATAL → 调用 AI 分析
    └─→ 无法判断级别 → 调用 AI 分析
```

### 本地过滤规则

#### 1. 级别检测

使用正则表达式检测日志级别：

| 级别 | 匹配模式 | 示例 |
|------|---------|------|
| TRACE | `\b(TRACE\|TRC)\b` | TRACE、TRC、[TRACE] |
| DEBUG | `\b(DEBUG\|DBG\|D)\b` | DEBUG、DBG、[D] |
| INFO | `\b(INFO\|INF\|I)\b` | INFO、INF、[I] |
| VERBOSE | `\bVERBOSE\b` | VERBOSE |

#### 2. 异常情况处理

即使是低级别日志，如果包含明显的错误关键词，也会交给 AI 判断：

**错误关键词列表：**
- ERROR
- EXCEPTION  
- FATAL
- CRITICAL
- FAILED
- FAILURE

**示例：**
```
❌ "2025-10-13 INFO User reported an error"
   虽然是 INFO，但包含 "error"，交给 AI 判断

✅ "2025-10-13 INFO User logged in successfully"
   INFO 且无错误关键词，本地过滤
```

## 💻 代码实现

### 核心函数

```go
// 本地预过滤：对于明确的低级别日志，直接过滤，不调用 AI
func tryLocalFilter(logLine string) *LogAnalysis {
    upperLine := strings.ToUpper(logLine)
    
    // 定义低级别日志模式
    lowLevelPatterns := []struct {
        level   string
        pattern string
        summary string
    }{
        {"TRACE", `\b(TRACE|TRC)\b`, "TRACE 级别日志"},
        {"DEBUG", `\b(DEBUG|DBG|D)\b`, "DEBUG 级别日志"},
        {"INFO", `\b(INFO|INF|I)\b`, "INFO 级别日志"},
        {"VERBOSE", `\bVERBOSE\b`, "VERBOSE 级别日志"},
    }
    
    for _, pattern := range lowLevelPatterns {
        matched, _ := regexp.MatchString(pattern.pattern, upperLine)
        if matched {
            // 检查是否包含错误关键词
            hasErrorKeywords := /* ... */
            
            if hasErrorKeywords {
                continue // 交给 AI 判断
            }
            
            // 本地过滤
            return &LogAnalysis{
                ShouldFilter: true,
                Summary:      pattern.summary,
                Reason:       "本地过滤：低级别日志",
            }
        }
    }
    
    return nil // 无法本地判断，需要 AI
}
```

### 调用流程

```go
func analyzeLog(logLine string, format string) (*LogAnalysis, error) {
    // 1. 尝试本地过滤
    if localAnalysis := tryLocalFilter(logLine); localAnalysis != nil {
        return localAnalysis, nil // 直接返回，不调用 AI
    }
    
    // 2. 本地无法判断，调用 AI
    systemPrompt := buildSystemPrompt(format)
    userPrompt := buildUserPrompt(logLine)
    response, _ := callPoeAPI(systemPrompt, userPrompt)
    // ...
}
```

## 🧪 测试验证

### 运行测试

```bash
./test-local-filter.sh
```

### 测试用例

#### 测试 1: DEBUG 日志（本地过滤）

```bash
echo '2025-10-13 DEBUG Entering method' | ./aipipe --format java --verbose
```

**预期结果：**
```
⚡ 本地过滤: 检测到 DEBUG 级别，直接过滤（不调用 AI）
🔇 [过滤] 2025-10-13 DEBUG Entering method
   原因: 本地过滤：DEBUG 级别的日志通常无需关注
```

**关键特征：**
- ✅ 看到「⚡ 本地过滤」提示
- ✅ 处理速度极快（< 0.1秒）
- ✅ 显示 🔇 [过滤]

#### 测试 2: INFO 日志（本地过滤）

```bash
echo '2025-10-13 INFO User logged in' | ./aipipe --format java --verbose
```

**预期结果：**
```
⚡ 本地过滤: 检测到 INFO 级别，直接过滤（不调用 AI）
🔇 [过滤] 2025-10-13 INFO User logged in
```

#### 测试 3: ERROR 日志（调用 AI）

```bash
echo '2025-10-13 ERROR Database failed' | ./aipipe --format java --verbose
```

**预期结果：**
```
⚠️  [重要] 2025-10-13 ERROR Database failed
   📝 摘要: 数据库失败
```

**关键特征：**
- ❌ 没有「本地过滤」提示
- ❌ 处理较慢（1-3秒）
- ✅ 调用了 AI 分析

#### 测试 4: INFO 但包含错误关键词（调用 AI）

```bash
echo '2025-10-13 INFO User reported an error' | ./aipipe --format java --verbose
```

**预期结果：**
- 不使用本地过滤
- 调用 AI 进行判断
- 避免误过滤重要信息

## 📊 性能对比

### 处理速度

| 方式 | 平均耗时 | 说明 |
|-----|---------|------|
| 本地过滤 | < 0.1秒 | 正则匹配，即时响应 |
| AI 分析 | 1-3秒 | 网络请求 + AI 处理 |
| **提升** | **10-30倍** | 显著提高响应速度 |

### API 调用减少

假设 1000 条日志中：
- DEBUG: 400 条（40%）
- INFO: 400 条（40%）
- WARN/ERROR: 200 条（20%）

**改进前：**
- API 调用：1000 次
- 总耗时：1000-3000秒

**改进后：**
- API 调用：200 次（只调用 WARN/ERROR）
- 总耗时：80 + 200-600秒 = 280-680秒
- **减少 API 调用：80%**
- **节省时间：60-75%**

### 费用节省

如果 API 按调用次数收费：
- 改进前：1000 次 × 单价 = 总费用
- 改进后：200 次 × 单价 = **节省 80% 费用**

## 🎯 适用场景

### 最适合的场景

1. **开发环境**
   - DEBUG 日志多
   - 节省调试时的 API 费用

2. **日志量大的生产环境**
   - INFO 日志占比高
   - 显著减少 API 调用

3. **实时监控**
   - 需要快速响应
   - 本地过滤降低延迟

### 不适合的场景

1. **所有日志都是 ERROR**
   - 本地过滤无用武之地
   - 仍需全部调用 AI

2. **自定义日志格式**
   - 不包含标准级别关键词
   - 无法本地识别

## 💡 调试技巧

### 1. 查看本地过滤日志

```bash
# 使用 verbose 模式
./aipipe -f app.log --format java --verbose

# 只看本地过滤的
./aipipe -f app.log --format java --verbose 2>&1 | grep "⚡ 本地过滤"
```

### 2. 统计本地过滤比例

```bash
# 查看过滤统计
tail -1000 app.log | ./aipipe --format java --verbose 2>&1 | \
    grep -E "(本地过滤|调用 AI)" | \
    sort | uniq -c
```

### 3. 测试特定日志

```bash
# 测试是否会本地过滤
echo "YOUR_LOG_LINE" | ./aipipe --format java --verbose
```

## 🔧 配置选项

### 修改低级别列表

如果你想添加或移除低级别：

编辑 `aipipe.go` 中的 `tryLocalFilter` 函数：

```go
lowLevelPatterns := []struct {
    level   string
    pattern string
    summary string
}{
    {"TRACE", `\b(TRACE|TRC)\b`, "TRACE 级别日志"},
    {"DEBUG", `\b(DEBUG|DBG|D)\b`, "DEBUG 级别日志"},
    {"INFO", `\b(INFO|INF|I)\b`, "INFO 级别日志"},
    // 添加你的自定义级别
    {"CUSTOM", `\bCUSTOM\b`, "自定义级别"},
}
```

### 修改错误关键词

如果你想调整错误关键词检测：

```go
hasErrorKeywords := strings.Contains(upperLine, "ERROR") ||
    strings.Contains(upperLine, "EXCEPTION") ||
    strings.Contains(upperLine, "FATAL") ||
    // 添加你的关键词
    strings.Contains(upperLine, "CUSTOM_ERROR")
```

## ✅ 最佳实践

### 1. 开发环境

```bash
# 开发时打开 verbose 查看过滤效果
./aipipe -f dev.log --format java --verbose
```

### 2. 生产环境

```bash
# 生产环境不需要 verbose，提高性能
./aipipe -f prod.log --format java
```

### 3. 性能监控

```bash
# 定期检查 API 调用次数
./aipipe -f app.log --format java --verbose 2>&1 | \
    grep -c "调用 Poe API"
```

## 📈 效果总结

| 指标 | 改进前 | 改进后 | 提升 |
|------|--------|--------|------|
| API 调用次数 | 100% | 20-40% | ↓ 60-80% |
| 平均处理速度 | 1.5秒/条 | 0.5秒/条 | ↑ 3倍 |
| API 费用 | 100% | 20-40% | ↓ 60-80% |
| 响应延迟 | 1-3秒 | < 0.1秒（低级别） | ↑ 10-30倍 |

## 🎉 总结

本地预过滤是一个重要的性能优化：

**✅ 优势：**
- 大幅减少 API 调用（60-80%）
- 显著提高处理速度（3-10倍）
- 降低运营成本
- 保持准确性（错误日志仍调用 AI）

**✅ 实现：**
- 简单的正则匹配
- 智能的异常检测
- 完全透明（用户无感知）

**✅ 安全：**
- 错误日志仍调用 AI
- 包含错误关键词的也交给 AI
- 保守策略，不会漏掉重要信息

---

**更新日期**: 2025-10-13  
**版本**: 1.4.0  
**状态**: ✅ 已实现并测试  
**预期效果**: 减少 60-80% API 调用

